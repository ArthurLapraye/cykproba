#! /usr/bin/python# -*- encoding: utf8 -*-# -------------------------------------------------------------------------## TP du 18/11/2015 - Implementation de l'algorithme CYK                    ##                                                                          ## Veillez a  bien commenter votre code et a  ce que la sortie du programme ## soit lisible et pertinente                                               ##                                                                          ## Vous devez envoyer votre code, accompagne d'un fichier PDF precisant     ## et expliquant tous les details de votre implementation, a                ## timothee.bernard@inria.fr avant le dimanche 22/11 a  23:59               ## -------------------------------------------------------------------------## Representations de deux grammairesg1 = [('S', 'AB'), ('S', 'a'), ('A', 'SB'), ('A', "b"), ('B', 'b')]g2 = [('S', 'AS'), ('S', 'b'), ('A', 'a')]def getAxiom(gr) :    return gr[0][0];# --------------------------## Base de l'algorithme CYK  ## --------------------------#"Initialisation de la table T pour le mot u et la grammaire gr"def init(T, u, gr) :    for i in range(1,len(u)+1) :                                                    #On parcourt le mot à reconnaitre        for (l,r) in gr :                                                               #On parcourt la grammaire            if (u[i-1] == r) :                                                          #Si la lettre en cours est identique à une partie droite de règle                if (i,i+1) not in T :                    T[(i,i+1)]=[(l,r)];                                                 #On remplit la case                else :                    T[(i,i+1)].append((l,r));                                           #On rajoute une autre règle s'il y en a + qu'une        if (i,i+1) not in T :            T[(i,i+1)]=[];                                                              #Si une case est vide, on ajoute un tableau vide dedans pour qu'elle apparaisse dans le dico    return T;"Remplissage de la table T (initialisation deja  effectuee) pour le mot u et la grammaire gr"def boucle(T,u,gr) :    for i in range(2,len(u)+1) :                                                       #On utilise y et i pour parcourir la chart        for y in range(1,(len(u)-i+2)) :            for j in range(y+1,i+y) :                                                  #La variable j est utilisée pour trouver la moitié du protomot                for (a,b) in T[(y,j)] :                                                #On regarde dans les paires de cases nécéssaire pour remplir la prochaine                    for (c,d) in T[(j,i+y)] :                        for (l,r) in gr :                                              #On parcourt la grammaire                            if (r == a+c) :                                            #S'il y a une règle dans la grammaire qui a en partie droite la concaténation des parties gauches des règles présentes dans les paires de cases                                if (y,i+y) not in T :                                    T[(y,i+y)]=[(l,r)];                                #On remplit la case                                else :                                    T[(y,i+y)].append((l,r));                          #On ajoute une autre règle s'il y en a + qu'une                if (y,i+y) not in T :                    T[(y,i+y)]=[];    return T;"Analyse du mot u pour la grammaire gr"def parsing(u, gr) :    T = {};    init(T, u, gr);    boucle(T, u, gr);    return T;# -----------------------------------------------------------------------## L'algo doit etre entierement code dans les fonctions precedentes ; les ## fonctions qui suivent servent uniquement a  afficher les resultats     ## et a  realiser facilement quelques tests                               ## -----------------------------------------------------------------------#"Une fois la table T remplie, determine si l'analyse a reussi"def interpretation(T, u, gr) :    print "T: " + str(T);    for (l,r) in T[(1, len(u)+1)] :                 #Pour tout couple dans la case en haut à droite de la chart        if (l == 'S') :                             #S'il y a une règle partant de l'axiome, le mot est reconnu, on revoie true            return True;    return False;"Une fois l'analyse effectuee, retrouve l'arbre syntaxique a  partir de la table"def affiche_arbre(T, u, gr) :    if interpretation(T, u, gr) :        chaine = "";        for i in range(1,len(u)+2) :            chaine = "";            for j in range(1,i) :                x = j;                y = len(u)+2-i+j;                chaine = chaine + str(T[x,y]) + " ";            print (s);    print;# ----------------## Quelques tests  ## ----------------#l_words = ["ab", "abb", "b", "aaaaab", "bb", "abab", "ca;b"];l_gram = [g1, g2];for g in l_gram :    print u"(Grammaire commencant par %s --> %s)" % (g[0][0], g[0][1]);    print;    for u in l_words :        T = parsing(u, g);        if interpretation(T, u, g) :            print "Le mot  ''", u, "''  est genere par la grammaire.";            print;            affiche_arbre(T, u, g);        else :            print "Le mot  ''", u, "''  N'est PAS genere par la grammaire.";    print;