#! /usr/bin/python# -*- encoding: utf8 -*-# -------------------------------------------------------------------------## TP du 18/11/2015 - Implementation de l'algorithme CYK                    ##                                                                          ## Veillez a  bien commenter votre code et a  ce que la sortie du programme ## soit lisible et pertinente                                               ##                                                                          ## Vous devez envoyer votre code, accompagne d'un fichier PDF precisant     ## et expliquant tous les details de votre implementation, a                ## timothee.bernard@inria.fr avant le dimanche 22/11 a  23:59               ## -------------------------------------------------------------------------## Representations de deux grammairesg1 = [('S', 'AB'), ('S', 'a'), ('A', 'SB'), ('A', "b"), ('B', 'b')]g2 = [('S', 'AS'), ('S', 'b'), ('A', 'a')]def getAxiom(gr) :    return gr[0][0]# --------------------------## Base de l'algorithme CYK  ## --------------------------#def init(T, u, gr) :    """        Initialisation de la table T pour le mot u et la grammaire gr    :param T: chart    :param u: mot à parser    :param gr: grammaire    :return: chart initialisée    """    for i in range(1,len(u)+1) :                       # On parcourt le mot à reconnaitre        for (l,r) in gr :                              # On parcourt la grammaire            if (u[i-1] == r) :                         # Si lettre en cours identique à partie droite de règle                if (i,i+1) not in T :                    T[(i,i+1)]=[(l,r)]                 # On remplit la case                else :                    T[(i,i+1)].append((l,r))           # On rajoute une autre règle s'il y en a + qu'une        if (i,i+1) not in T :            T[(i,i+1)]=[]                              # Si case vide, ajout tableau vide dedans    return Tdef boucle(T,u,gr) :    """        Remplissage de la table T (initialisation deja  effectuee) pour le mot u et la grammaire gr    :param T: chart    :param u: mot à parser    :param gr: grammaire    :return: chart    """    for i in range(2,len(u)+1) :                                         # On utilise y et i pour parcourir la chart        for y in range(1,(len(u)-i+2)) :            for j in range(y+1,i+y) :                                    # La variable j est utilisée pour trouver la moitié du protomot                for (a,b) in T[(y,j)] :                                  # On regarde dans les paires de cases nécéssaire pour remplir la prochaine                    for (c,d) in T[(j,i+y)] :                        for (l,r) in gr :                                # On parcourt la grammaire                            if (r == a+c) :                              # S'il y a une règle dans la grammaire qui a en partie droite la concaténation des parties gauches des règles présentes dans les paires de cases                                if (y,i+y) not in T :                                    T[(y,i+y)]=[(l,r)]                   # On remplit la case                                else :                                    T[(y,i+y)].append((l,r))             # On ajoute une autre règle s'il y en a + qu'une                if (y,i+y) not in T :                    T[(y,i+y)]=[]    return Tdef parsing(u, gr) :    """        Analyse du mot u pour la grammaire gr    :param u: mot à parser    :param gr: grammaire    :return: charte (dictionnaire)    """    T = {}    init(T, u, gr)    boucle(T, u, gr)    return T# -----------------------------------------------------------------------## L'algo doit etre entierement code dans les fonctions precedentes ; les ## fonctions qui suivent servent uniquement a  afficher les resultats     ## et a  realiser facilement quelques tests                               ## -----------------------------------------------------------------------#def interpretation(T, u, gr) :    """        Une fois la table T remplie, determine si l'analyse a reussi    :param T: chart    :param u: mot à parser    :param gr: grammaire    :return: booléen ( True/False )    """    # return any([True if l == "S" for (l,_) in T[(1, len(u)+1)]])    print ("T: " + str(T))    for (l,r) in T[(1, len(u)+1)]:                  #Pour tout couple dans la case en haut à droite de la chart        if (l == 'S'):                              #S'il y a une règle partant de l'axiome, le mot est reconnu, on revoie true            return True    return Falsedef affiche_arbre(T, u, gr):    """        Une fois l'analyse effectuee, retrouve l'arbre syntaxique a  partir de la table    :param T: chart    :param u: mot à parser    :param gr: grammaire    :return: arbre(s) possible(s) du mot à parser    """    if interpretation(T, u, gr):        chaine = ""        for i in range(1,len(u)+2):            chaine = ""            for j in range(1,i):                x = j                y = len(u)+2-i+j                chaine += str(T[x,y]) + " "            print(s)    print()# ----------------## Quelques tests  ## ----------------#l_words = ["ab", "abb", "b", "aaaaab", "bb", "abab", "ca;b"]l_gram = [g1, g2]for g in l_gram :    print ("(Grammaire commencant par {0} --> {1})".format(g[0][0], g[0][1]))    print()    for u in l_words :        T = parsing(u, g)        if interpretation(T, u, g) :            print ("Le mot {0} est généré par la grammaire.".format(u))            print()            affiche_arbre(T, u, g)        else :            print ("Le mot '{0}' N'est PAS généré par la grammaire".format(u))    print()